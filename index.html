



<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" type="text/css" href="/css/bootstrap.min.css" />
<link rel="stylesheet" type="text/css" href="/css/custom.css" />
<title>Main - Leif Andersen</title>
</head>
<body id="pn-top"><header><nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark"><div class="container"><a class="navbar-brand" href="/index.html">Home</a>
<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button></div></nav></header>
<main role="main"><div class="jumbotron"><div class="container"><h1>Leif Andersen</h1></div></div>
<div class="container"><img src="/res/Leif.jpg" alt="Leif Andersen" style="width:500px" />
<h2>Bio</h2>
<a href="https://www.ccis.northeastern.edu/people/leif-anderson/">On CCIS</a>
<h2>Papers</h2>
<ul class="list-group"><li class="list-group-item"><div class="container"><div class="row">Super 8 Languages for Making Movies</div>
<div class="row"><strong>Authors:&nbsp;</strong>
Leif Andersen, Stephen Chang, Matthias Felleisen</div>
<div class="row"><a href="https://doi.org/10.1145/3110274">[Publisher PDF]</a></div>
<div class="row"><div class="collapse-group"><strong>Abstract:&nbsp;</strong>
<p class="collapse" id="viewabstract">The Racket doctrine tells developers to create languages (as libraries) to
narrow the gap between the terminology of a problem domain and general
programming constructs. This pearl illustrates this doctrine with the creation
of a relatively simple domain-specific language for editing videos. To produce
the video proceedings of a conference, for example, video professionals
traditionally use ``non-linear'' GUI editors to manually edit each talk,
despite the repetitive nature of the process. As it turns out, the task of
video editing naturally splits into a declarative phase and an imperative
rendering phase at the end. Hence it is natural to create a
functional-declarative language for the first phase, which reduces a lot of
manual labor. The implementation of this user-facing DSL, dubbed Video,
utilizes a second, internal DSL to implement the second phase, which is an
interface to a general, low-level C library. Finally, we inject type checking
into our Video language via another DSL that supports programming in the
language of type formalisms. In short, the development of the video editing
language cleanly demonstrates how the Racket doctrine naturally leads to the
creation of language hierarchies, analogous to the hierarchies of modules found
in conventional functional languages.</p>
<a class="btn" data-toggle="collapse" data-target="#viewabstract">View...</a></div></div></div></li><li class="list-group-item"><div class="container"><div class="row">Feature-Specific Profiling</div>
<div class="row"><strong>Authors:&nbsp;</strong>
Vincent St-Amout, Leif Andersen, Matthias Felleisen</div>
<div class="row"><a href="https://doi.org/10.1007/978-3-662-46663-6_3">[Publisher PDF]</a></div>
<div class="row"><div class="collapse-group"><strong>Abstract:&nbsp;</strong>
<p class="collapse" id="viewabstract">High-level languages come with significant readability and maintainability
benefits. Their performance costs, however, are usually not predictable, at
least not easily. Programmers may accidentally use high-level features in ways
that compiler writers could not anticipate, and they may thus produce
underperforming programs as a result.

This paper introduces feature-specific profiling, a profiling technique that
reports performance costs in terms of linguistic constructs. With a
feature-specific profiler, a programmer can identify specific instances of
language features that are responsible for performance problems. After
explaining the architecture of our feature-specific profiler, the paper
presents the evidence in support of adding feature-specific profiling to the
programmer’s toolset.</p>
<a class="btn" data-toggle="collapse" data-target="#viewabstract">View...</a></div></div></div></li><li class="list-group-item"><div class="container"><div class="row">Concrete and Abstract Interpretation: Better Together</div>
<div class="row"><strong>Authors:&nbsp;</strong>
Maria Jenkins, Leif Andersen, Thomas Gilray, Matthew Might</div>
<div class="row"><a href="http://homes.soic.indiana.edu/jhemann/scheme-14/papers/Jenkins2014.pdf">[Publisher PDF]</a></div>
<div class="row"><div class="collapse-group"><strong>Abstract:&nbsp;</strong>
<p class="collapse" id="viewabstract">Recent work in abstracting abstract machines provides a methodology for
deriving sound static analyzers from a concrete semantics by way of abstract
interpretation. Consequently, the concrete and abstract semantics are closely
related by design. We apply Galois-unions as a framework for combining both
concrete and abstract semantics, and explore the benefits of being able to
express both in a single semantics. We present a methodology for creating such
a unified representation using operational semantics and implement our approach
with and A-normal form (ANF) λ-calculus for a CESK style machine in PLT
Redex.</p>
<a class="btn" data-toggle="collapse" data-target="#viewabstract">View...</a></div></div></div></li><li class="list-group-item"><div class="container"><div class="row">Multi-core Parallelization of Abstract Abstract Machines </div>
<div class="row"><strong>Authors:&nbsp;</strong>
Leif Andersen, Matthew Might</div>
<div class="row"><a href="http://www.schemeworkshop.org/2013/papers/Andersen2013.pdf">[Publisher PDF]</a></div>
<div class="row"><div class="collapse-group"><strong>Abstract:&nbsp;</strong>
<p class="collapse" id="viewabstract">It is straightforward to derive well-known higher-order flow analyses as
abstract interpretations of well-known abstract machines. In this paper, we
explore multi-core parallel evaluation of one such abstract abstract machine,
the CES machine. The CES machine is a variant of CESK machines that runs
Continuation Passing Style (CPS) λ-calculus. Using k-CFA, the concrete
semantics for a CES machine can be turned into abstract semantics. Analyzing a
program for this machine is a state graph walk, which can be run in parallel to
increase performance.</p>
<a class="btn" data-toggle="collapse" data-target="#viewabstract">View...</a></div></div></div></li></ul></div></main>
<footer class="container"><div class="copyright"><p style="float:left">Copyright © 2014-2018 Leif Andersen</p></div></footer><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script></body></html>
